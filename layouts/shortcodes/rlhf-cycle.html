<style>
    /* rlhf-cycle Styles */
    .rlhf-cycle {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        border-radius: 12px;
        padding: 2rem;
        margin: 2rem 0;
        border: 1px solid #e0e0e0;
        position: relative;
        min-height: 600px;
        overflow: visible;
    }

    /* Prompt Display */
    .rlhf-cycle .prompt-container {
        display: flex;
        justify-content: center;
        margin-bottom: 2rem;
    }

    .rlhf-cycle .prompt-display {
        background: white;
        padding: 1.5rem 2rem;
        border-radius: 8px;
        font-size: 1.5rem;
        font-weight: 500;
        color: #333;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        min-width: 300px;
    }

    /* Content Container - mirrored layout */
    .rlhf-cycle .content-container {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 3rem;
        margin: 3rem 0;
        min-height: 280px;
        position: relative;
    }

    /* Answers Container (LEFT side) */
    .rlhf-cycle .answers-container {
        flex: 1;
        max-width: 450px;
        min-height: 280px;
        position: relative;
    }

    /* LLM and Controls Container (RIGHT side) */
    .rlhf-cycle .llm-controls-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.5rem;
    }

    /* Answer Block */
    .rlhf-cycle .answer-block {
        background: white;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        opacity: 1;
        position: relative;
        border-left: 4px solid transparent;
        transition: all 0.3s ease;
    }

    .rlhf-cycle .answer-block.hidden {
        opacity: 0;
    }

    .rlhf-cycle .answer-header {
        font-weight: 700;
        color: #667eea;
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
        text-transform: uppercase;
    }

    .rlhf-cycle .answer-content {
        color: #333;
        line-height: 1.6;
        font-size: 0.95rem;
    }

    .rlhf-cycle .ranking-badge {
        margin-top: 0.75rem;
        padding: 0.5rem;
        background: rgba(76, 175, 80, 0.1);
        border-radius: 4px;
        font-size: 0.85rem;
        color: #4caf50;
        font-weight: 600;
        display: none;
    }

    .rlhf-cycle .ranking-badge.visible {
        display: block;
    }

    /* Ranking color indicators */
    .rlhf-cycle .answer-block.rank-1 {
        border-left-color: #4caf50;
    }
    .rlhf-cycle .answer-block.rank-2 {
        border-left-color: #ff9800;
    }
    .rlhf-cycle .answer-block.rank-3 {
        border-left-color: #f44336;
    }

    /* LLM Box (RIGHT side) */
    .rlhf-cycle .llm-box {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 12px;
        padding: 1.5rem;
        width: 220px;
        height: 220px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        position: relative;
        color: white;
        flex-shrink: 0;
    }

    .rlhf-cycle .llm-label {
        font-size: 1.8rem;
        font-weight: 700;
        letter-spacing: 2px;
        text-align: center;
    }

    /* Training Meter */
    .rlhf-cycle .training-meter {
        width: 180px;
        height: 30px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        position: relative;
        overflow: hidden;
        border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .rlhf-cycle .meter-fill {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #4caf50 0%, #66bb6a 100%);
        border-radius: 15px;
        transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .rlhf-cycle .meter-label {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.9rem;
        font-weight: 600;
        color: white;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        pointer-events: none;
        white-space: nowrap;
    }

    /* Processing Indicator */
    .rlhf-cycle .processing-indicator {
        width: 35px;
        height: 35px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top-color: white;
        border-radius: 50%;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .rlhf-cycle .processing-indicator.active {
        opacity: 1;
        animation: spin-rlhf 1s linear infinite;
    }

    @keyframes spin-rlhf {
        to {
            transform: rotate(360deg);
        }
    }

    /* Controls */
    .rlhf-cycle .controls {
        display: flex;
        justify-content: center;
    }

    .rlhf-cycle .action-button {
        padding: 1rem 2rem;
        font-size: 1.1rem;
        font-weight: 600;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .rlhf-cycle .action-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
    }

    .rlhf-cycle .action-button:active:not(:disabled) {
        transform: translateY(0);
    }

    .rlhf-cycle .action-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

    .rlhf-cycle .create-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }

    .rlhf-cycle .feedback-button {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
    }

    .rlhf-cycle .training-button {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        color: white;
    }

    .rlhf-cycle .final-button {
        background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
        color: white;
    }

    .rlhf-cycle .reset-button {
        background: #e0e0e0;
        color: #333;
    }

    /* Animation Particles */
    .rlhf-cycle .animation-particle {
        position: absolute;
        background: white;
        padding: 0.8rem 1.2rem;
        border-radius: 6px;
        font-size: 1.3rem;
        font-weight: 500;
        color: #333;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        opacity: 0;
        pointer-events: none;
        z-index: 100;
        left: 50%;
        transform: translateX(-50%);
    }

    /* Prompt flowing into LLM (right side) */
    .rlhf-cycle .prompt-particle.animating {
        animation: promptFlowInRLHF 0.3s ease-in forwards;
    }

    @keyframes promptFlowInRLHF {
        0% {
            top: 120px;
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }
        100% {
            top: 280px;
            left: calc(100% - 110px);
            opacity: 0;
            transform: translateX(-50%) scale(0.7);
        }
    }

    /* Answer exiting LLM in arc to left */
    .rlhf-cycle .answer-particle.animating-exit {
        animation: answerExitArc 0.3s ease-out forwards;
    }

    @keyframes answerExitArc {
        0% {
            top: 280px;
            left: calc(100% - 110px);
            opacity: 1;
            transform: translateX(-50%) scale(0.8);
        }
        40% {
            top: 200px;
            left: calc(100% - 300px);
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }
        100% {
            top: 280px;
            left: calc(100% - 450px);
            opacity: 0;
            transform: translateX(-50%) scale(0.9);
        }
    }

    /* Answer block appearing on left */
    .rlhf-cycle .answer-block.appearing {
        animation: answerAppearLeft 0.3s ease-out forwards;
    }

    @keyframes answerAppearLeft {
        0% {
            opacity: 0;
            transform: translateX(50px) scale(0.9);
        }
        100% {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
    }

    /* Answer reordering */
    .rlhf-cycle .answer-block.reordering {
        transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 10;
    }

    /* Answer sliding into LLM */
    .rlhf-cycle .answer-block.training {
        animation: answerSlideIntoLLM 0.4s ease-in forwards;
    }

    @keyframes answerSlideIntoLLM {
        0% {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
        100% {
            opacity: 0;
            transform: translateX(400px) scale(0.3);
        }
    }

    /* Dark Mode */
    @media (prefers-color-scheme: dark) {
        .rlhf-cycle {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-color: #333;
        }

        .rlhf-cycle .prompt-display,
        .rlhf-cycle .answer-block {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
        }

        .rlhf-cycle .answer-header {
            color: #8b9bea;
        }

        .rlhf-cycle .answer-content {
            color: #e0e0e0;
        }

        .rlhf-cycle .meter-label {
            color: white;
        }

        .rlhf-cycle .reset-button {
            background: #444;
            color: #e0e0e0;
        }

        .rlhf-cycle .animation-particle {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
        }
    }

    /* Responsive Design */
    @media (max-width: 800px) {
        .rlhf-cycle {
            padding: 1rem;
            min-height: 550px;
        }

        .rlhf-cycle .content-container {
            flex-direction: column-reverse;
            gap: 2rem;
            align-items: center;
        }

        .rlhf-cycle .answers-container {
            max-width: 100%;
            width: 100%;
        }

        .rlhf-cycle .llm-controls-container {
            gap: 1rem;
        }

        .rlhf-cycle .prompt-display {
            font-size: 1.2rem;
            padding: 1rem 1.5rem;
            min-width: 250px;
        }

        .rlhf-cycle .llm-box {
            width: 180px;
            height: 180px;
            padding: 1rem;
        }

        .rlhf-cycle .llm-label {
            font-size: 1.5rem;
        }

        .rlhf-cycle .training-meter {
            width: 150px;
            height: 25px;
        }

        .rlhf-cycle .meter-label {
            font-size: 0.8rem;
        }

        .rlhf-cycle .action-button {
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
        }

        .rlhf-cycle .animation-particle {
            font-size: 1.1rem;
            padding: 0.6rem 1rem;
        }

        .rlhf-cycle .answer-content {
            font-size: 0.9rem;
        }
    }
</style>

<div class="rlhf-cycle">
    <!-- Prompt Display -->
    <div class="prompt-container">
        <div class="prompt-display" id="promptDisplayRLHF">
            Explain quantum computing
        </div>
    </div>

    <!-- Content Container -->
    <div class="content-container">
        <!-- Answers Container (LEFT) -->
        <div class="answers-container" id="answersContainerRLHF"></div>

        <!-- LLM Box and Controls (RIGHT) -->
        <div class="llm-controls-container">
            <div class="llm-box" id="llmBoxRLHF">
                <div class="llm-label" id="llmLabelRLHF">LLM</div>
                <div class="training-meter">
                    <div class="meter-fill" id="meterFillRLHF"></div>
                    <div class="meter-label" id="meterLabelRLHF">
                        0% trained
                    </div>
                </div>
                <div
                    class="processing-indicator"
                    id="processingIndicatorRLHF"
                ></div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <button
                    id="actionButtonRLHF"
                    class="action-button create-button"
                >
                    Create Answers
                </button>
            </div>
        </div>
    </div>

    <!-- Animation Particles -->
    <div
        class="animation-particle prompt-particle"
        id="promptParticleRLHF"
    ></div>
    <div
        class="animation-particle answer-particle"
        id="answerParticleRLHF"
    ></div>
</div>

<script>
    (function () {
        "use strict";

        // State Management
        let trainingLevel = 0; // Index into [0, 1, 2, 3] = [0%, 33%, 66%, 100%]
        const TRAINING_LEVELS = [0, 33, 66, 100];
        const PERCENT_PER_ANSWER = 11; // 3 answers × 11% = 33%

        let currentPhase = "create"; // 'create' | 'feedback' | 'training' | 'final' | 'complete'
        let answersCreatedInPhase = 0; // 0-3
        const MAX_ANSWERS = 3;

        let currentAnswers = []; // Array of {letter, text, element, ranking}
        let buttonState = "create";
        let isAnimating = false;

        // Content data structure
        const content = {
            0: {
                responses: {
                    A: "Quantum computing quantum mechanics quantum bits qubit superposition entanglement algorithm...",
                    B: "Computing with quantum particles using physics principles for calculations.",
                    C: "Quantum computing is a type of computation that harnesses quantum mechanical phenomena.",
                },
                feedback: {
                    rankings: ["C", "B", "A"],
                    reasons: {
                        C: "Clear and accurate",
                        B: "Too brief",
                        A: "Word salad",
                    },
                },
            },
            33: {
                responses: {
                    A: "Quantum computing uses qubits instead of regular bits. Qubits can be 0 and 1 at same time. This makes quantum computers fast.",
                    B: "Quantum computing leverages quantum mechanics to process information differently than classical computers, using quantum bits that can exist in superposition states.",
                    C: "Unlike classical computers that use bits (0 or 1), quantum computers use qubits which can be in multiple states simultaneously through superposition.",
                },
                feedback: {
                    rankings: ["C", "B", "A"],
                    reasons: {
                        C: "Best explanation for general audience",
                        B: "Good but slightly technical",
                        A: "Too simplified",
                    },
                },
            },
            66: {
                responses: {
                    A: "Quantum computing is an advanced computing paradigm that leverages quantum mechanical phenomena like superposition and entanglement. Unlike classical computers that process bits as either 0 or 1, quantum computers use qubits that can exist in multiple states simultaneously, enabling parallel computation at unprecedented scales.",
                    B: "Quantum computing represents a fundamentally different approach to computation. Classical computers use bits (0 or 1), while quantum computers use qubits that can be 0, 1, or both simultaneously through superposition. This allows quantum computers to solve certain complex problems exponentially faster than classical computers.",
                    C: "Quantum computers work differently from regular computers by using quantum bits. These qubits can represent multiple values at once, making quantum computers very powerful for specific types of calculations.",
                },
                feedback: {
                    rankings: ["B", "A", "C"],
                    reasons: {
                        B: "Excellent balance and clarity",
                        A: "Very good but slightly dense",
                        C: "Good attempt but oversimplified for this level",
                    },
                },
            },
            100: {
                final: "Quantum computing is a revolutionary computing paradigm that harnesses quantum mechanical phenomena—particularly superposition and entanglement—to process information in fundamentally different ways than classical computers. While classical computers use bits that exist in definite states of 0 or 1, quantum computers use qubits that can exist in superposition, representing multiple states simultaneously. This enables quantum computers to explore vast solution spaces in parallel, making them exponentially faster for specific problem classes such as cryptography, molecular simulation, and optimization. Though still in early stages of development, quantum computing promises to transform fields from drug discovery to artificial intelligence.",
            },
        };

        // DOM Elements
        const promptDisplay = document.getElementById("promptDisplayRLHF");
        const actionButton = document.getElementById("actionButtonRLHF");
        const promptParticle = document.getElementById("promptParticleRLHF");
        const answerParticle = document.getElementById("answerParticleRLHF");
        const processingIndicator = document.getElementById(
            "processingIndicatorRLHF",
        );
        const meterFill = document.getElementById("meterFillRLHF");
        const meterLabel = document.getElementById("meterLabelRLHF");
        const llmLabel = document.getElementById("llmLabelRLHF");
        const answersContainer = document.getElementById(
            "answersContainerRLHF",
        );

        // Utility Functions
        function delay(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
        }

        function updateMeter(percentage) {
            meterFill.style.width = percentage + "%";
            meterLabel.textContent = percentage + "% trained";
        }

        function updateLLMLabel(text) {
            llmLabel.textContent = text;
        }

        function updateButton() {
            const level = TRAINING_LEVELS[trainingLevel];

            if (level === 100 && currentPhase === "final") {
                actionButton.textContent = "Final Answer";
                actionButton.className = "action-button final-button";
                buttonState = "final";
            } else if (level === 100 && currentPhase === "complete") {
                actionButton.textContent = "Start Over";
                actionButton.className = "action-button reset-button";
                buttonState = "reset";
            } else if (
                currentPhase === "create" &&
                answersCreatedInPhase < MAX_ANSWERS
            ) {
                actionButton.textContent = "Create Answers";
                actionButton.className = "action-button create-button";
                buttonState = "create";
            } else if (currentPhase === "feedback") {
                actionButton.textContent = "Human Feedback";
                actionButton.className = "action-button feedback-button";
                buttonState = "feedback";
            } else if (currentPhase === "training") {
                actionButton.textContent = "Training";
                actionButton.className = "action-button training-button";
                buttonState = "training";
            }
        }

        function createAnswerBlock(letter, text) {
            const block = document.createElement("div");
            block.className = "answer-block hidden";
            block.dataset.answer = letter;

            const header = document.createElement("div");
            header.className = "answer-header";
            header.textContent = "Response " + letter;

            const content = document.createElement("div");
            content.className = "answer-content";
            content.textContent = text;

            const badge = document.createElement("div");
            badge.className = "ranking-badge";

            block.appendChild(header);
            block.appendChild(content);
            block.appendChild(badge);

            return block;
        }

        // CREATE ANSWERS Phase
        async function createAnswer(letter) {
            const level = TRAINING_LEVELS[trainingLevel];
            const responseText = content[level].responses[letter];

            // Step 1: Prompt flows into LLM (0.3s)
            promptParticle.textContent = "Explain quantum computing";
            promptParticle.classList.add("animating");
            await delay(300);
            promptParticle.classList.remove("animating");

            // Step 2: Processing indicator (0.3s)
            processingIndicator.classList.add("active");
            await delay(300);
            processingIndicator.classList.remove("active");

            // Step 3: Answer exits LLM in arc to left (0.3s)
            answerParticle.textContent = "Response " + letter;
            answerParticle.classList.add("animating-exit");
            await delay(300);
            answerParticle.classList.remove("animating-exit");

            // Step 4: Answer block appears in answers container (0.3s)
            const answerBlock = createAnswerBlock(letter, responseText);
            answersContainer.appendChild(answerBlock);
            answerBlock.classList.add("appearing");
            await delay(300);
            answerBlock.classList.remove("appearing", "hidden");

            // Store for later phases
            currentAnswers.push({
                letter,
                text: responseText,
                element: answerBlock,
            });

            answersCreatedInPhase++;

            // Check if all answers created
            if (answersCreatedInPhase >= MAX_ANSWERS) {
                currentPhase = "feedback";
            }
        }

        // CREATE ALL ANSWERS Phase (creates all 3 answers sequentially)
        async function createAllAnswers() {
            const letters = ["A", "B", "C"];
            for (let i = 0; i < MAX_ANSWERS; i++) {
                await createAnswer(letters[i]);
            }
        }

        // HUMAN FEEDBACK Phase
        async function applyFeedback() {
            const level = TRAINING_LEVELS[trainingLevel];
            const rankings = content[level].feedback.rankings;
            const reasons = content[level].feedback.reasons;

            // Step 1: Calculate current positions
            const answerPositions = currentAnswers.map((answer, index) => ({
                answer,
                currentIndex: index,
                rect: answer.element.getBoundingClientRect(),
            }));

            // Step 2: Determine target order based on rankings
            const targetOrder = rankings.map((letter) =>
                currentAnswers.find((a) => a.letter === letter),
            );

            // Step 3: Calculate moves and apply transforms
            targetOrder.forEach((answer, targetIndex) => {
                const currentIndex = currentAnswers.indexOf(answer);
                const rankClass =
                    targetIndex === 0
                        ? "rank-1"
                        : targetIndex === 1
                          ? "rank-2"
                          : "rank-3";

                answer.element.classList.add(rankClass, "reordering");

                // Calculate vertical offset (approximate height + margin)
                const avgHeight = 100;
                const moveDistance = (targetIndex - currentIndex) * avgHeight;
                answer.element.style.transform = `translateY(${moveDistance}px)`;
            });

            await delay(800);

            // Step 4: Reorder in DOM and add ranking badges
            answersContainer.innerHTML = "";
            targetOrder.forEach((answer, index) => {
                answer.element.style.transform = "";
                answer.element.classList.remove("reordering");
                answersContainer.appendChild(answer.element);

                // Add ranking badge
                const badge = answer.element.querySelector(".ranking-badge");
                badge.textContent = reasons[answer.letter];
                badge.classList.add("visible");
            });

            // Update current order
            currentAnswers = targetOrder;

            currentPhase = "training";
            updateButton();
        }

        // TRAINING Phase - single answer
        async function trainWithAnswer(answer, answerNumber) {
            // Step 1: Answer slides into LLM (0.4s)
            answer.element.classList.add("training");

            // Step 2: Simultaneously, meter increments
            const currentPercent =
                TRAINING_LEVELS[trainingLevel] +
                (answerNumber + 1) * PERCENT_PER_ANSWER;
            updateMeter(Math.min(currentPercent, 99));

            await delay(400);

            // Step 3: Remove answer block
            answer.element.remove();

            await delay(100);
        }

        // TRAINING Phase - train all answers sequentially
        async function trainAllAnswers() {
            const answersToTrain = [...currentAnswers];

            for (let i = 0; i < answersToTrain.length; i++) {
                await trainWithAnswer(answersToTrain[i], i);
            }

            // Training phase complete
            currentAnswers = [];
            trainingLevel++;
            currentPhase = "create";
            answersCreatedInPhase = 0;

            const newLevel = TRAINING_LEVELS[trainingLevel];
            if (newLevel === 100) {
                currentPhase = "final";
            }

            updateMeter(newLevel);
        }

        // FINAL ANSWER Phase
        async function showFinalAnswer() {
            const finalText = content[100].final;

            // Clear answers container
            answersContainer.innerHTML = "";

            // Create final answer block
            const finalBlock = createAnswerBlock("Final", finalText);
            finalBlock.querySelector(".answer-header").textContent =
                "Final Answer";
            answersContainer.appendChild(finalBlock);
            finalBlock.classList.add("appearing", "rank-1");

            await delay(500);

            currentPhase = "complete";
            updateButton();
        }

        // RESET
        function executeReset() {
            trainingLevel = 0;
            currentPhase = "create";
            answersCreatedInPhase = 0;
            currentAnswers = [];
            buttonState = "create";
            isAnimating = false;

            // Clear UI
            answersContainer.innerHTML = "";
            promptDisplay.textContent = "Explain quantum computing";
            updateMeter(0);
            updateButton();
        }

        // Button Click Handler
        async function handleButtonClick() {
            if (isAnimating) return;

            isAnimating = true;
            actionButton.disabled = true;

            try {
                switch (buttonState) {
                    case "create":
                        await createAllAnswers();
                        break;
                    case "feedback":
                        await applyFeedback();
                        break;
                    case "training":
                        await trainAllAnswers();
                        break;
                    case "final":
                        await showFinalAnswer();
                        break;
                    case "reset":
                        executeReset();
                        break;
                }

                updateButton();
            } finally {
                isAnimating = false;
                actionButton.disabled = false;
            }
        }

        // Initialize
        actionButton.addEventListener("click", handleButtonClick);
        updateMeter(0);
        updateButton();
    })();
</script>
